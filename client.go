package glide

import (
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/retitle/go-sdk/glide_errors"
	"github.com/retitle/go-sdk/http_utils"
	"github.com/retitle/go-sdk/models"
	"github.com/retitle/go-sdk/resources"
	"github.com/retitle/go-sdk/security"
)

type impersonating struct {
	sub                string
	scopes             []string
	accessToken        string
	accessTokenExpires time.Time
}

type Options struct {
	Protocol string
	Server   string
	BasePath string
	Audience string
}

type client struct {
	clientKey     string
	key           security.Key
	options       *Options
	impersonating *impersonating

	// DO NOT remove these comments since they serve as anchors for code autogeneration
	/* Autogenerated-root-resource-defs begins */
	Transactions resources.TransactionsResource
	Users        resources.UsersResource
	/* Autogenerated-root-resource-defs ends */
}

const JWT_EXPIRES = 60

func getOptions(options *Options) *Options {
	defaultOptions := Options{
		Protocol: "https",
		Server:   "api.glide.com",
		BasePath: "/",
		Audience: "",
	}

	if options == nil {
		defaultOptions.Audience = defaultOptions.Server
		return &defaultOptions
	}

	coalesceString := func(v1 string, v2 string) string {
		if v1 != "" {
			return v1
		}
		return v2
	}

	server := coalesceString(options.Server, defaultOptions.Server)
	effectiveOptions := Options{
		Protocol: coalesceString(options.Protocol, defaultOptions.Protocol),
		Server:   server,
		BasePath: coalesceString(options.BasePath, defaultOptions.BasePath),
		Audience: coalesceString(coalesceString(options.Audience, defaultOptions.Audience), server),
	}

	return &effectiveOptions
}

func GetClient(clientKey string, key security.Key, options *Options) *client {
	c := client{
		clientKey: clientKey,
		key:       key,
		options:   getOptions(options),
	}
	// DO NOT remove these comments since they serve as anchors for code autogeneration
	/* Autogenerated-root-resource-init begins */
	c.Transactions = resources.GetTransactionsResource(&c)
	c.Users = resources.GetUsersResource(&c)
	/* Autogenerated-root-resource-init ends */
	return &c
}

func (c client) getUrl(path string) string {
	return fmt.Sprintf("%s://%s%s%s", strings.ToLower(c.options.Protocol),
		strings.ToLower(c.options.Server),
		strings.ToLower(c.options.BasePath),
		strings.ToLower(path),
	)
}

func (c client) request(authRequired bool, doRequest func() *glide_errors.ApiError) *glide_errors.ApiError {
	if authRequired && c.IsImpersonating() {
		c.refreshAccessToken()
	}

	return doRequest()
}

func (c client) getHeaders(headers *http.Header) http.Header {
	if headers == nil {
		headers = &http.Header{}
	}
	if c.IsImpersonating() {
		headers.Add("Authorization", fmt.Sprintf("Bearer %s", c.impersonating.accessToken))
	}
	return *headers
}

func (c client) getQueryParams(qParams *http_utils.QueryParams) http_utils.QueryParams {
	if qParams == nil {
		return http_utils.QueryParams{}
	}

	return *qParams
}

func (c client) Get(res models.Response, authRequired bool, path string, headers *http.Header, qParams *http_utils.QueryParams) *glide_errors.ApiError {
	return c.request(authRequired, func() *glide_errors.ApiError {
		return http_utils.Get(res, c.getUrl(path), c.getHeaders(headers), c.getQueryParams(qParams))
	})
}

func (c client) Post(res models.Response, authRequired bool, path string, headers *http.Header, qParams *http_utils.QueryParams, payload models.Request) *glide_errors.ApiError {
	return c.request(authRequired, func() *glide_errors.ApiError {
		return http_utils.Post(res, c.getUrl(path), c.getHeaders(headers), c.getQueryParams(qParams), payload)
	})
}

func (c client) getJwt(sub string, scopes []string) (string, *glide_errors.ApiError) {
	return getJwt(c.key, c.clientKey, sub, c.options.Audience, scopes, JWT_EXPIRES)
}

func (c client) getAccessToken(sub string, scopes []string) (*models.JwtOauthAccessToken, *glide_errors.ApiError) {
	assertionsJwt, err := c.getJwt(sub, scopes)
	if err != nil {
		return nil, &glide_errors.ApiError{
			Params: map[string]interface{}{
				"desc": "Error issuing assertions JWT",
				"err":  err,
			},
		}
	}

	data := models.JwtOauthAccessToken{}
	if err = c.Post(&data, false, "/oauth/token", nil, nil, models.JwtOauth{
		GrantType: "JWT",
		Assertion: assertionsJwt,
	}); err != nil {
		return nil, err
	}

	if data.AccessToken == "" {
		if data.RequestScopesUrl != "" {
			err = &glide_errors.ApiError{
				Description: "Need user consent to access scopes",
				Params: map[string]interface{}{
					"missing_scopes":     data.MissingScopes,
					"request_scopes_url": data.RequestScopesUrl,
				},
			}
		} else {
			err = &glide_errors.ApiError{
				Description: "Unknown error",
				Params: map[string]interface{}{
					"data": data,
				},
			}
		}
		return nil, err
	}

	return &data, nil
}

func (c *client) StartImpersonating(sub string, scopes []string) *glide_errors.ApiError {
	data, err := c.getAccessToken(sub, scopes)
	if err != nil {
		return err
	}

	c.impersonating = &impersonating{
		sub:                sub,
		scopes:             scopes,
		accessToken:        data.AccessToken,
		accessTokenExpires: time.Now().Add(time.Second * time.Duration(data.ExpiresIn)),
	}

	return nil
}

func (c client) IsImpersonating() bool {
	return c.impersonating != nil
}

func (c client) ImpersonatingSub() string {
	if c.IsImpersonating() {
		return c.impersonating.sub
	}
	return ""
}

func (c client) ImpersonatingScopes() []string {
	if c.IsImpersonating() {
		return c.impersonating.scopes
	}
	return []string{}
}

func (c *client) StopImpersonating() {
	c.impersonating = nil
}

func (c client) isTokenExpired() bool {
	return time.Now().After(c.impersonating.accessTokenExpires)
}

func (c client) isTokenAboutToExpire() bool {
	// Consider an access token "about to expire" if it's set to expire in less than 15m
	return !c.isTokenExpired() && time.Now().After(c.impersonating.accessTokenExpires.Add(time.Minute*time.Duration(-15)))
}

func (c client) shouldRefreshToken() bool {
	return c.IsImpersonating() && (c.isTokenAboutToExpire() || c.isTokenExpired())
}

func (c *client) refreshAccessToken() *glide_errors.ApiError {
	if c.shouldRefreshToken() {
		data, err := c.getAccessToken(c.impersonating.sub, c.impersonating.scopes)

		if err != nil {
			// fail silently if token is not yet expired
			if c.isTokenExpired() {
				return err
			}
		} else {
			c.impersonating.accessToken = data.AccessToken
			c.impersonating.accessTokenExpires = time.Now().Add(time.Second * time.Duration(data.ExpiresIn))
		}
	}

	return nil
}
